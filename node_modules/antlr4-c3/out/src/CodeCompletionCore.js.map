{"version":3,"file":"CodeCompletionCore.js","sourceRoot":"","sources":["../../src/CodeCompletionCore.ts"],"names":[],"mappings":"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","sourcesContent":["/*\n * This file is released under the MIT license.\n * Copyright (c) 2016, 2020, Mike Lischke\n *\n * See LICENSE file for more info.\n */\n\n'use strict';\n\nimport { Parser, Vocabulary, Token, TokenStream, ParserRuleContext } from 'antlr4ts';\nimport {\n    ATN, ATNState, ATNStateType, Transition, TransitionType, PredicateTransition, RuleTransition, RuleStartState,\n    PrecedencePredicateTransition\n} from 'antlr4ts/atn';\nimport { IntervalSet } from 'antlr4ts/misc/IntervalSet';\n\nexport type TokenList = number[];\n\nexport type CandidateRule = {\n    startTokenIndex: number,\n    ruleList: RuleList,\n}\n\nexport type RuleWithStartToken = {\n    startTokenIndex: number,\n    ruleIndex: number;\n}\n\nexport type RuleWithStartTokenList = RuleWithStartToken[];\nexport type RuleList = number[];\n\n// All the candidates which have been found. Tokens and rules are separated.\n// Token entries include a list of tokens that directly follow them (see also the \"following\" member in the\n// FollowSetWithPath class).\n// Rule entries include the index of the starting token within the evaluated rule, along with a call stack of rules\n// found during evaluation.\nexport class CandidatesCollection {\n    public tokens: Map<number, TokenList> = new Map();\n    public rules: Map<number, CandidateRule> = new Map();\n};\n\n// A record for a follow set along with the path at which this set was found.\n// If there is only a single symbol in the interval set then we also collect and store tokens which follow\n// this symbol directly in its rule (i.e. there is no intermediate rule transition). Only single label transitions\n// are considered. This is useful if you have a chain of tokens which can be suggested as a whole, because there is\n// a fixed sequence in the grammar.\nclass FollowSetWithPath {\n    public intervals: IntervalSet;\n    public path: RuleList = [];\n    public following: TokenList = [];\n};\n\n// A list of follow sets (for a given state number) + all of them combined for quick hit tests.\n// This data is static in nature (because the used ATN states are part of a static struct: the ATN).\n// Hence it can be shared between all C3 instances, however it depends on the actual parser class (type).\nclass FollowSetsHolder {\n    public sets: FollowSetWithPath[];\n    public combined: IntervalSet;\n};\n\ntype FollowSetsPerState = Map<number, FollowSetsHolder>;\n\n// Token stream position info after a rule was processed.\ntype RuleEndStatus = Set<number>;\n\nclass PipelineEntry {\n    state: ATNState;\n    tokenListIndex: number;\n};\n\n// The main class for doing the collection process.\nexport class CodeCompletionCore {\n    // Debugging options. Print human readable ATN state and other info.\n\n    // Not dependent on showDebugOutput. Prints the collected rules + tokens to terminal.\n    public showResult = false;\n\n    // Enables printing ATN state info to terminal.\n    public showDebugOutput = false;\n\n    // Only relevant when showDebugOutput is true. Enables transition printing for a state.\n    public debugOutputWithTransitions = false;\n\n    // Also depends on showDebugOutput. Enables call stack printing for each rule recursion.\n    public showRuleStack = false;\n\n    // Tailoring of the result:\n    // Tokens which should not appear in the candidates set.\n    public ignoredTokens: Set<number>;\n\n    // Rules which replace any candidate token they contain.\n    // This allows to return descriptive rules (e.g. className, instead of ID/identifier).\n    public preferredRules: Set<number>;\n\n    // Specify if preferred rules should translated top-down (higher index rule returns first) or\n    // bottom-up (lower index rule returns first).\n    public translateRulesTopDown = false;\n\n    private parser: Parser;\n    private atn: ATN;\n    private vocabulary: Vocabulary;\n    private ruleNames: string[];\n    private tokens: Token[];\n    private precedenceStack: Array<number>;\n\n    private tokenStartIndex: number = 0;\n    private statesProcessed: number = 0;\n\n    // A mapping of rule index + token stream position to end token positions.\n    // A rule which has been visited before with the same input position will always produce the same output positions.\n    private shortcutMap: Map<number, Map<number, RuleEndStatus>> = new Map();\n    private candidates: CandidatesCollection = new CandidatesCollection(); // The collected candidates (rules and tokens).\n\n    private static followSetsByATN: Map<string, FollowSetsPerState> = new Map();\n\n    constructor(parser: Parser) {\n        this.parser = parser;\n        this.atn = parser.atn;\n        this.vocabulary = parser.vocabulary;\n        this.ruleNames = parser.ruleNames;\n        this.ignoredTokens = new Set();\n        this.preferredRules = new Set();\n    }\n\n    /**\n     * This is the main entry point. The caret token index specifies the token stream index for the token which currently\n     * covers the caret (or any other position you want to get code completion candidates for).\n     * Optionally you can pass in a parser rule context which limits the ATN walk to only that or called rules.\n     * This can significantly speed up the retrieval process but might miss some candidates (if they are outside of\n     * the given context).\n     */\n    public collectCandidates(caretTokenIndex: number, context?: ParserRuleContext): CandidatesCollection {\n        this.shortcutMap.clear();\n        this.candidates.rules.clear();\n        this.candidates.tokens.clear();\n        this.statesProcessed = 0;\n        this.precedenceStack = [];\n\n        this.tokenStartIndex = context ? context.start.tokenIndex : 0;\n        let tokenStream: TokenStream = this.parser.inputStream;\n\n        this.tokens = [];\n        let offset = this.tokenStartIndex;\n        while (true) {\n            const token = tokenStream.get(offset++);\n            if (token.channel === Token.DEFAULT_CHANNEL) {\n                this.tokens.push(token);\n\n                if (token.tokenIndex >= caretTokenIndex || token.type == Token.EOF) {\n                    break;\n                }\n            }\n\n            // Do not check for the token index here, as we want to end with the first unhidden token on or after\n            // the caret.\n            if (token.type == Token.EOF) {\n                break;\n            }\n        }\n\n        let callStack: RuleWithStartTokenList = [];\n        let startRule = context ? context.ruleIndex : 0;\n        this.processRule(this.atn.ruleToStartState[startRule], 0, callStack, 0, 0);\n\n        if (this.showResult) {\n            console.log(\"States processed: \" + this.statesProcessed);\n            console.log(\"\\n\\nCollected rules:\\n\");\n            for (let rule of this.candidates.rules) {\n                let path = \"\";\n                for (let token of rule[1].ruleList) {\n                    path += this.ruleNames[token] + \" \";\n                }\n                console.log(this.ruleNames[rule[0]] + \", path: \", path);\n            }\n\n            const sortedTokens: Set<string> = new Set();\n            for (let token of this.candidates.tokens) {\n                let value = this.vocabulary.getDisplayName(token[0]);\n                for (let following of token[1])\n                    value += \" \" + this.vocabulary.getDisplayName(following);\n                sortedTokens.add(value);\n            }\n\n            console.log(\"\\n\\nCollected tokens:\\n\");\n            for (let symbol of sortedTokens) {\n                console.log(symbol);\n            }\n            console.log(\"\\n\\n\");\n        }\n\n        return this.candidates;\n    }\n\n    /**\n     * Checks if the predicate associated with the given transition evaluates to true.\n     */\n    private checkPredicate(transition: PredicateTransition): boolean {\n        return transition.predicate.eval(this.parser, ParserRuleContext.emptyContext());\n    }\n\n    /**\n     * Walks the rule chain upwards or downwards (depending on translateRulesTopDown) to see if that matches any of the\n     * preferred rules. If found, that rule is added to the collection candidates and true is returned.\n     */\n    private translateStackToRuleIndex(ruleWithStartTokenList: RuleWithStartTokenList): boolean {\n        if (this.preferredRules.size == 0) {\n            return false;\n        }\n\n        // Change the direction we iterate over the rule stack\n        if (this.translateRulesTopDown) {\n            // Loop over the rule stack from lowest to highest rule level. This will prioritize a lower preferred rule\n            // if it is a child of a higher one that is also a preferred rule.\n            for (let i = ruleWithStartTokenList.length - 1; i >= 0; i--) {\n                if (this.translateToRuleIndex(i, ruleWithStartTokenList)) {\n                    return true;\n                }\n            }\n        } else {\n            // Loop over the rule stack from highest to lowest rule level. This will prioritize a higher preferred rule\n            // if it contains a lower one that is also a preferred rule.\n            for (let i = 0; i < ruleWithStartTokenList.length; i++) {\n                if (this.translateToRuleIndex(i, ruleWithStartTokenList)) {\n                    return true;\n                }\n            }\n        }\n\n\n        return false;\n    }\n\n    /**\n     * Given the index of a rule from a rule chain, check if that matches any of the preferred rules. If it matches,\n     * that rule is added to the collection candidates and true is returned.\n     */\n    private translateToRuleIndex(i: number, ruleWithStartTokenList: RuleWithStartTokenList): boolean {\n        const { ruleIndex, startTokenIndex } = ruleWithStartTokenList[i];\n        if (this.preferredRules.has(ruleIndex)) {\n            // Add the rule to our candidates list along with the current rule path,\n            // but only if there isn't already an entry like that.\n            const path = ruleWithStartTokenList.slice(0, i).map(({ ruleIndex }) => ruleIndex);\n            let addNew = true;\n            for (let rule of this.candidates.rules) {\n                if (rule[0] != ruleIndex || rule[1].ruleList.length != path.length) {\n                    continue;\n                }\n\n                // Found an entry for this rule. Same path? If so don't add a new (duplicate) entry.\n                if (path.every((v, j) => v === rule[1].ruleList[j])) {\n                    addNew = false;\n                    break;\n                }\n            }\n\n            if (addNew) {\n                this.candidates.rules.set(ruleIndex, {\n                    startTokenIndex,\n                    ruleList: path,\n                });\n                if (this.showDebugOutput) {\n                    console.log(\"=====> collected: \", this.ruleNames[ruleIndex]);\n                }\n            }\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * This method follows the given transition and collects all symbols within the same rule that directly follow it\n     * without intermediate transitions to other rules and only if there is a single symbol for a transition.\n     */\n    private getFollowingTokens(transition: Transition): number[] {\n        const result: number[] = [];\n\n        const pipeline: ATNState[] = [transition.target];\n\n        while (pipeline.length > 0) {\n            const state = pipeline.pop();\n\n            for (let transition of state!.getTransitions()) {\n                if (transition.serializationType == TransitionType.ATOM) {\n                    if (!transition.isEpsilon) {\n                        let list = transition.label!.toArray();\n                        if (list.length == 1 && !this.ignoredTokens.has(list[0])) {\n                            result.push(list[0]);\n                            pipeline.push(transition.target);\n                        }\n                    } else {\n                        pipeline.push(transition.target);\n                    }\n                }\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Entry point for the recursive follow set collection function.\n     */\n    private determineFollowSets(start: ATNState, stop: ATNState): FollowSetWithPath[] {\n        const result: FollowSetWithPath[] = [];\n        const stateStack: ATNState[] = [];\n        const ruleStack: number[] = [];\n        this.collectFollowSets(start, stop, result, stateStack, ruleStack);\n\n        return result;\n    }\n\n    /**\n     * Collects possible tokens which could be matched following the given ATN state. This is essentially the same\n     * algorithm as used in the LL1Analyzer class, but here we consider predicates also and use no parser rule context.\n     */\n    private collectFollowSets(s: ATNState, stopState: ATNState, followSets: FollowSetWithPath[], stateStack: ATNState[],\n        ruleStack: number[]) {\n\n        if (stateStack.find(x => x == s)) {\n            return;\n        }\n        stateStack.push(s);\n\n        if (s == stopState || s.stateType == ATNStateType.RULE_STOP) {\n            let set = new FollowSetWithPath();\n            set.intervals = IntervalSet.of(Token.EPSILON);\n            set.path = ruleStack.slice();\n            followSets.push(set);\n            stateStack.pop();\n            return;\n        }\n\n        for (let transition of s.getTransitions()) {\n            if (transition.serializationType == TransitionType.RULE) {\n                let ruleTransition: RuleTransition = transition as RuleTransition;\n                if (ruleStack.indexOf(ruleTransition.target.ruleIndex) != -1) {\n                    continue;\n                }\n\n                ruleStack.push(ruleTransition.target.ruleIndex);\n                this.collectFollowSets(transition.target, stopState, followSets, stateStack, ruleStack);\n                ruleStack.pop();\n\n            } else if (transition.serializationType == TransitionType.PREDICATE) {\n                if (this.checkPredicate(transition as PredicateTransition)) {\n                    this.collectFollowSets(transition.target, stopState, followSets, stateStack, ruleStack);\n                }\n            } else if (transition.isEpsilon) {\n                this.collectFollowSets(transition.target, stopState, followSets, stateStack, ruleStack);\n            } else if (transition.serializationType == TransitionType.WILDCARD) {\n                let set = new FollowSetWithPath();\n                set.intervals = IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, this.atn.maxTokenType);\n                set.path = ruleStack.slice();\n                followSets.push(set);\n            } else {\n                let label = transition.label;\n                if (label && label.size > 0) {\n                    if (transition.serializationType == TransitionType.NOT_SET) {\n                        label = label.complement(IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, this.atn.maxTokenType));\n                    }\n                    const set = new FollowSetWithPath();\n                    set.intervals = label;\n                    set.path = ruleStack.slice();\n                    set.following = this.getFollowingTokens(transition);\n                    followSets.push(set);\n                }\n            }\n        }\n        stateStack.pop();\n    }\n\n    /**\n     * Walks the ATN for a single rule only. It returns the token stream position for each path that could be matched\n     * in this rule.\n     * The result can be empty in case we hit only non-epsilon transitions that didn't match the current input or if we\n     * hit the caret position.\n     */\n    private processRule(startState: RuleStartState, tokenListIndex: number, callStack: RuleWithStartTokenList,\n        precedence: number, indentation: number): RuleEndStatus {\n\n        // Start with rule specific handling before going into the ATN walk.\n\n        // Check first if we've taken this path with the same input before.\n        let positionMap = this.shortcutMap.get(startState.ruleIndex);\n        if (!positionMap) {\n            positionMap = new Map();\n            this.shortcutMap.set(startState.ruleIndex, positionMap);\n        } else {\n            if (positionMap.has(tokenListIndex)) {\n                if (this.showDebugOutput) {\n                    console.log(\"=====> shortcut\");\n                }\n                return positionMap.get(tokenListIndex)!;\n            }\n        }\n\n        const result: RuleEndStatus = new Set<number>();\n\n        // For rule start states we determine and cache the follow set, which gives us 3 advantages:\n        // 1) We can quickly check if a symbol would be matched when we follow that rule. We can so check in advance\n        //    and can save us all the intermediate steps if there is no match.\n        // 2) We'll have all symbols that are collectable already together when we are at the caret when entering a rule.\n        // 3) We get this lookup for free with any 2nd or further visit of the same rule, which often happens\n        //    in non trivial grammars, especially with (recursive) expressions and of course when invoking code\n        //    completion multiple times.\n        let setsPerState = CodeCompletionCore.followSetsByATN.get(this.parser.constructor.name);\n        if (!setsPerState) {\n            setsPerState = new Map();\n            CodeCompletionCore.followSetsByATN.set(this.parser.constructor.name, setsPerState);\n        }\n\n        let followSets = setsPerState.get(startState.stateNumber);\n        if (!followSets) {\n            followSets = new FollowSetsHolder();\n            setsPerState.set(startState.stateNumber, followSets);\n            let stop = this.atn.ruleToStopState[startState.ruleIndex];\n            followSets.sets = this.determineFollowSets(startState, stop);\n\n            // Sets are split by path to allow translating them to preferred rules. But for quick hit tests\n            // it is also useful to have a set with all symbols combined.\n            let combined = new IntervalSet();\n            for (let set of followSets.sets) {\n                combined.addAll(set.intervals);\n            }\n            followSets.combined = combined;\n        }\n\n        // Get the token index where our rule starts from our (possibly filtered) token list\n        const startTokenIndex = this.tokens[tokenListIndex].tokenIndex;\n\n        callStack.push({\n            startTokenIndex,\n            ruleIndex: startState.ruleIndex,\n        });\n\n        if (tokenListIndex >= this.tokens.length - 1) { // At caret?\n            if (this.preferredRules.has(startState.ruleIndex)) {\n                // No need to go deeper when collecting entries and we reach a rule that we want to collect anyway.\n                this.translateStackToRuleIndex(callStack);\n            } else {\n                // Convert all follow sets to either single symbols or their associated preferred rule and add\n                // the result to our candidates list.\n                for (let set of followSets.sets) {\n                    const fullPath = callStack.slice();\n\n                    // Rules derived from our followSet will always start at the same token as our current rule\n                    const followSetPath = set.path.map(path => ({\n                        startTokenIndex,\n                        ruleIndex: path,\n                    }));\n\n                    fullPath.push(...followSetPath);\n                    if (!this.translateStackToRuleIndex(fullPath)) {\n                        for (let symbol of set.intervals.toArray())\n                            if (!this.ignoredTokens.has(symbol)) {\n                                if (this.showDebugOutput) {\n                                    console.log(\"=====> collected: \", this.vocabulary.getDisplayName(symbol));\n                                }\n                                if (!this.candidates.tokens.has(symbol)) {\n                                    // Following is empty if there is more than one entry in the set.\n                                    this.candidates.tokens.set(symbol, set.following);\n                                } else {\n                                    // More than one following list for the same symbol.\n                                    if (this.candidates.tokens.get(symbol) != set.following) {\n                                        this.candidates.tokens.set(symbol, []);\n                                    }\n                                }\n                            }\n                    }\n                }\n            }\n\n            callStack.pop();\n            return result;\n\n        } else {\n            // Process the rule if we either could pass it without consuming anything (epsilon transition)\n            // or if the current input symbol will be matched somewhere after this entry point.\n            // Otherwise stop here.\n            const currentSymbol = this.tokens[tokenListIndex].type;\n            if (!followSets.combined.contains(Token.EPSILON) && !followSets.combined.contains(currentSymbol)) {\n                callStack.pop();\n                return result;\n            }\n        }\n\n        if (startState.isPrecedenceRule) {\n            this.precedenceStack.push(precedence);\n        }\n\n        // The current state execution pipeline contains all yet-to-be-processed ATN states in this rule.\n        // For each such state we store the token index + a list of rules that lead to it.\n        const statePipeline: PipelineEntry[] = [];\n        let currentEntry;\n\n        // Bootstrap the pipeline.\n        statePipeline.push({ state: startState, tokenListIndex: tokenListIndex });\n\n        while (statePipeline.length > 0) {\n            currentEntry = statePipeline.pop()!;\n            ++this.statesProcessed;\n\n            const currentSymbol = this.tokens[currentEntry.tokenListIndex].type;\n\n            const atCaret = currentEntry.tokenListIndex >= this.tokens.length - 1;\n            if (this.showDebugOutput) {\n                this.printDescription(indentation, currentEntry.state, this.generateBaseDescription(currentEntry.state),\n                    currentEntry.tokenListIndex);\n                if (this.showRuleStack)\n                    this.printRuleState(callStack);\n            }\n\n            if (currentEntry.state.stateType == ATNStateType.RULE_STOP) {\n                // Record the token index we are at, to report it to the caller.\n                result.add(currentEntry.tokenListIndex);\n                continue;\n            }\n\n            const transitions = currentEntry.state.getTransitions();\n\n            // We simulate here the same precedence handling as the parser does, which uses hard coded values.\n            // For rules that are not left recursive this value is ignored (since there is no precedence transition).\n            for (let transition of transitions) {\n                switch (transition.serializationType) {\n                    case TransitionType.RULE: {\n                        const ruleTransition = transition as RuleTransition;\n                        const endStatus = this.processRule(transition.target as RuleStartState,\n                            currentEntry.tokenListIndex, callStack, ruleTransition.precedence, indentation + 1);\n                        for (let position of endStatus) {\n                            statePipeline.push({\n                                state: (<RuleTransition>transition).followState,\n                                tokenListIndex: position\n                            });\n                        }\n                        break;\n                    }\n\n                    case TransitionType.PREDICATE: {\n                        if (this.checkPredicate(transition as PredicateTransition))\n                            statePipeline.push({\n                                state: transition.target,\n                                tokenListIndex: currentEntry.tokenListIndex\n                            });\n                        break;\n                    }\n\n                    case TransitionType.PRECEDENCE: {\n                        const predTransition = transition as PrecedencePredicateTransition;\n                        if (predTransition.precedence >= this.precedenceStack[this.precedenceStack.length - 1])\n                            statePipeline.push({\n                                state: transition.target,\n                                tokenListIndex: currentEntry.tokenListIndex\n                            });\n\n                        break;\n                    }\n\n                    case TransitionType.WILDCARD: {\n                        if (atCaret) {\n                            if (!this.translateStackToRuleIndex(callStack)) {\n                                for (let token of IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, this.atn.maxTokenType)\n                                    .toArray()) {\n                                    if (!this.ignoredTokens.has(token)) {\n                                        this.candidates.tokens.set(token, []);\n                                    }\n                                }\n                            }\n                        } else {\n                            statePipeline.push({\n                                state: transition.target,\n                                tokenListIndex: currentEntry.tokenListIndex + 1\n                            });\n                        }\n                        break;\n                    }\n\n                    default: {\n                        if (transition.isEpsilon) {\n                            // Jump over simple states with a single outgoing epsilon transition.\n                            statePipeline.push({\n                                state: transition.target,\n                                tokenListIndex: currentEntry.tokenListIndex\n                            });\n                            continue;\n                        }\n\n                        let set = transition.label;\n                        if (set && set.size > 0) {\n                            if (transition.serializationType == TransitionType.NOT_SET) {\n                                set = set.complement(IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, this.atn.maxTokenType));\n                            }\n                            if (atCaret) {\n                                if (!this.translateStackToRuleIndex(callStack)) {\n                                    let list = set.toArray();\n                                    let addFollowing = list.length == 1;\n                                    for (let symbol of list)\n                                        if (!this.ignoredTokens.has(symbol)) {\n                                            if (this.showDebugOutput) {\n                                                console.log(\"=====> collected: \",\n                                                    this.vocabulary.getDisplayName(symbol));\n                                            }\n\n                                            if (addFollowing) {\n                                                this.candidates.tokens.set(symbol, this.getFollowingTokens(transition));\n                                            } else {\n                                                this.candidates.tokens.set(symbol, []);\n                                            }\n                                        }\n                                }\n                            } else {\n                                if (set.contains(currentSymbol)) {\n                                    if (this.showDebugOutput) {\n                                        console.log(\"=====> consumed: \", this.vocabulary.getDisplayName(currentSymbol));\n                                    }\n                                    statePipeline.push({\n                                        state: transition.target,\n                                        tokenListIndex: currentEntry.tokenListIndex + 1\n                                    });\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        callStack.pop();\n        if (startState.isPrecedenceRule) {\n            this.precedenceStack.pop();\n        }\n\n        // Cache the result, for later lookup to avoid duplicate walks.\n        positionMap.set(tokenListIndex, result);\n\n        return result;\n    }\n\n    private atnStateTypeMap: string[] = [\n        \"invalid\",\n        \"basic\",\n        \"rule start\",\n        \"block start\",\n        \"plus block start\",\n        \"star block start\",\n        \"token start\",\n        \"rule stop\",\n        \"block end\",\n        \"star loop back\",\n        \"star loop entry\",\n        \"plus loop back\",\n        \"loop end\"\n    ]\n\n    private generateBaseDescription(state: ATNState): string {\n        const stateValue = state.stateNumber == ATNState.INVALID_STATE_NUMBER ? \"Invalid\" : state.stateNumber;\n\n        return \"[\" + stateValue + \" \" + this.atnStateTypeMap[state.stateType] + \"] in \" +\n            this.ruleNames[state.ruleIndex];\n    }\n\n    private printDescription(indentation: number, state: ATNState, baseDescription: string, tokenIndex: number) {\n\n        const indent = \"  \".repeat(indentation);\n        let output = indent;\n\n        let transitionDescription = \"\";\n        if (this.debugOutputWithTransitions) {\n            for (let transition of state.getTransitions()) {\n                let labels = \"\";\n                let symbols: number[] = transition.label ? transition.label.toArray() : [];\n                if (symbols.length > 2) {\n                    // Only print start and end symbols to avoid large lists in debug output.\n                    labels = this.vocabulary.getDisplayName(symbols[0]) + \" .. \" +\n                        this.vocabulary.getDisplayName(symbols[symbols.length - 1]);\n                } else {\n                    for (let symbol of symbols) {\n                        if (labels.length > 0) {\n                            labels += \", \";\n                        }\n                        labels += this.vocabulary.getDisplayName(symbol);\n                    }\n                }\n                if (labels.length == 0) {\n                    labels = \"ε\";\n                }\n                transitionDescription += \"\\n\" + indent + \"\\t(\" + labels + \") \" + \"[\" +\n                    transition.target.stateNumber + \" \" + this.atnStateTypeMap[transition.target.stateType] + \"] in \" +\n                    this.ruleNames[transition.target.ruleIndex];\n            }\n        }\n\n        if (tokenIndex >= this.tokens.length - 1) {\n            output += \"<<\" + this.tokenStartIndex + tokenIndex + \">> \";\n        } else {\n            output += \"<\" + this.tokenStartIndex + tokenIndex + \"> \";\n        }\n        console.log(output + \"Current state: \" + baseDescription + transitionDescription);\n    }\n\n    private printRuleState(stack: RuleWithStartTokenList) {\n        if (stack.length == 0) {\n            console.log(\"<empty stack>\");\n            return;\n        }\n\n        for (let rule of stack) {\n            console.log(this.ruleNames[rule.ruleIndex]);\n        }\n    }\n\n}\n"]}